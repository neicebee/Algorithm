# 💻 비트 연산자

- 들어가기 전
  - `False == 0`
  - `True == 1`

## `&, |, ^, <<, >>`

### a=69, b=15

- `&`: AND => 둘 다 참일 경우 1
  - **a&b**
    - ```python
      a = 69
      b = 15
      print("=========")
      print(f"69&15\n{69&15}(10)")
      print(f"{bin(69&15)}(2)")
      print("=========")
      ```
    - **result**
    - ```
      =========
      69&15
      5(10)
      0b101(2)
      =========
      ```
- `|`: OR => 둘 중 하나만 참일 경우 1
  - **a|b**
    - **result**
    - ```
      =========
      69|15
      79(10)
      0b1001111(2)
      =========
      ```
- `^`: XOR => 둘 중 하나만 참이어도 1
  - **a^b**
    - **result**
    - ```
      =========
      69^15
      74(10)
      0b1001010(2)
      =========
      ```
- `<<`: 왼쪽 쉬프트 연산
  - **b<<2**
    - **result**
    - ```
      =========
      b<<2
      60(10)
      0b111100(2)
      =========
      ```
- `>>`: 오른쪽 쉬프트 연산
  - **a>>3**
      - **result**
      - ```
        =========
        a>>3
        8(10)
        0b1000(2)
        =========
        ```

## `~`

**비트 반전 연산자(bitwise NOT operator)**

를 알아보기 전에 알아보는 **_보수_**

- **보수**란?
  - 보충하는 수를 의미
  - 10진수에는 **10의 보수**와 **9의 보수** 사용
    - 10의 보수: 숫자의 합을 **_10의 제곱수_** 로 만들어주기 위해 더해줘야 하는 수
      - 10의 보수는 9의 보수를 취한 후 +1을 하면 구할 수 있음
    - 9의 보수: 숫자의 합을 **_10의 제곱수 - 1_** 로 만들어주기 위해 더해줘야 하는 수
      - 9의 보수는 각 자리수의 값에 9에서 빼주면 구할 수 있음
    - Example
      - 4(10)의 9의 보수 => 5
        - 9 - 4 = 5 => 각 자리수의 값을 9에서 빼줌
      - 4(10)의 10의 보수 => 6
        - 9 - 4 + 1 = 6 => 9의 보수에서 +1
      - 21(10)의 9의 보수 => 78
        - 99 - 21 = 78
      - 21(10)의 10의 보수 => 79
        - 99 - 21 + 1 = 79
  - 2진수에서는 **2의 보수**와 **1의 보수** 사용
     - 2의 보수: 숫자의 합을 **_2의 제곱수_** 로 만들어주기 위해 더해줘야 하는 수
     - 1의 보수: 숫자의 합을 **_2의 제곱수 - 1_** 로 만들어주기 위해 더해줘야 하는 수
       - 1의 보수는 각 자릿수를 1에서 빼면 구할 수 있는데 이는 **비트 반전**과 동일
     - Example
       - 1001(2)의 1의 보수 => 0110
         - 1111 - 1001 = 0110 => 각 자릿수의 값을 1에서 빼줌. **_비트 반전_**
       - 1001(2)의 2의 보수 => 0111
         - 1111 - 1001 + 1 = 0111 => 1의 보수에서 +1
   - 컴퓨터의 보수 사용 이유?
     - 음수 사용 위해서
   - 컴퓨터의 음수 표현 이유?
     - 컴퓨터는 뺄셈을 하지 못함. 양수를 2의 보수로 변환한 뒤 덧셈을 하는 형식으로 연산해야 함
   - Example => 8 - 3
     - 10진수인 8와 3를 2진수로 변환
     - 1000(2) - 0011(2)
       - 0011(2)의 2의 보수 => 1100(2)
     - 1000(2) + 1100(2)
       - 10101(2) => 우리는 4비트 자료형을 사용하므로 맨 끝 비트는 무시함
         - 0101(2) => 5(10)
     - Result
       - 8 - 3 = 5

- 0은 1로 1은 0으로 바꾸는 연산자
- "비트를 뒤집는다.", "비트 반전" 이라고 불리움

`-x`: x에 대한 부호를 바꿈. x의 값이 0인 경우 변하지 않음

`~x`: x의 모든 비트를 뒤집음.
  - x의 2진수 표현이 0000 0110이면 ~x는 1111 1001이 됨

Example => 7
  - 7(10) => 0111(2)
  - ~7(10) => 1000(2)
    ```python
    print(~7)
    ```
  - Result
    ```
    -8
    ``` 
  - 파이썬에서 ~7을 출력하면 1000(2)가 아닌 -8을 출력함
  - 1000(2)은 컴퓨터가 인식하는 ~7. 컴퓨터가 연산을 하기 위해 2의 보수로 음수를 저장한 것
  >> 음수를 저장하기 이해 2의 보수를 취했으므로 음수를 해석하기 위해서는 2의 보수를 역으로 취해주어야 함. 1의 보수를 취하고 +1을 했으므로 -1을 한 후 1의 보수를 취해주어야 함
  - ~7 => 1000(2): 2의 보수를 취하고 저장된 음수
    - Most Significant Bit(최상위 비트): 0이면 양수, 1이면 음수
  - 1000(2) - 1 = 0111(2)
  - 0111(2)의 1의 보수 => 1000(2) => -0b1000 => -8
  - 즉, `~x = -(x+1)`

**결론**

>> ~x는 -(x+1)과 같음