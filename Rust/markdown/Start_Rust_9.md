# 🦀 Rust Day 9

## **🏳️ Understanding Ownership**
- 소유권은 러스트의 독특한 기능 중 하나
- 가비지 콜렉터(Garbage Collector)에 의존하지 않고도 메모리 안정성을 보장하려는 러스트만의 해법
  - `Garbage Collection` (통칭 GC)
    - 메모리 관리 방법 중 하나로, 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아내어 해제하는 기능
    - **_시스템에서 가비지 컬렉션을 수행하는 부분을 컬렉터라 칭함_**
    - 보통 쓰레기 수집 기능을 채택한 언어의 경우 프로그래머에게 직접적인 메모리 할당과 해제를 하게 하는 대신에 쓰레기 수집기에서 제공하는 할당과 해제를 사용하게 하여 프로그램이 실행되는 중간중간에 쓸모가 없어진 메모리, 즉 쓰레기를 알아서 수집함

### **1️⃣ 소유권이란?**
- **소유권은 러스트의 핵심 기능. 언어 전체에 깊이 관여하고 있는 개념**
- 프로그램들의 메모리 관리 방법
  - 가비지 콜렉터를 이용해 메모리를 관리하는 언어
  - 프로그래머가 명시적으로 메모리를 할당하고 해제해 주어야 하는 언어
- 러스트는 제 3의 방법 사용
  - 메모리는 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로 이루어진 `소유권 시스템` 에 의해 관리됨
  - 때문에 소유권과 관련된 기능은 프로그램의 실행 성능에 아무런 영향을 미치지 않음
  - _러스트와 소유권 시스템의 규칙에 익숙해질수록 더 안전하며 효율적인 코드 작성 가능_
- **스택(Stack) 메모리와 힙(Heap) 메모리**
  - 러스트 같은 시스템 프로그래밍 언어 환경에서는 값이 스택 메모리에 저장되었는지 힙 메모리에 저장되었는지에 따라 언어의 동작이나 의사결정에 큰 영향을 미침
  - 스택과 힙은 코드가 런타임에 활용하는 메모리의 일부이며 각자 다른 방법으로 데이터를 구성함
  - **스택(Stack)**
    - 유입된 순서대로 데이터 저장
    - 읽을 때는 유입된 반대 순서
      - 즉, 마지막에 들어온 값을 가장 먼저 읽는 구조(LIFO, Last In, First Out)
    - 쌓인 데이터 중간에 다른 데이터를 삽입하거나 꺼내는 동작은 허용되지 않음
    - 스택에 새로운 데이터를 쌓는 동작 => `push`
    - 스택의 제일 위에서 데이터를 꺼내는 동작 => `pop`
    - 스택에 저장하는 모든 데이터는 고정된 크기를 가져야 함
  - **힙(Heap)**
    - 컴파일 시점에 크기를 알 수 없는 데이터나 런타임에 동적으로 크기가 변하는 데이터는 힙에 저장
    - 스택에 비해 복잡함
    - 힙에 데이터를 넣는 동작은 메모리의 일정 공간을 할애할 것을 요청하는 것 => OS는 힙 메모리에서 일정 공간을 찾아 사용중인 메모리로 표시한 후, 해당 메모리의 주솟값인 포인터(pointer)를 넘겨줌
    - 위의 과정을 `힙 메모리 할당(allocating on the heap)` 또는 단순히 `할당(allocating)` 이라고 칭함
    - **_스택에 값을 푸시하는 동작에는 할당이 발생하지 않음_**
      - 포인터는 이미 크기가 고정된 값이므로 포인터는 스택에 저장할 수 있지만, 실제 포인터가 가리키는 데이터가 필요할 때는 포인터가 가리키는 메모리를 따라가야 함
  - 스택에 데이터를 푸시하는 것이 힙에 할당하는 것보다 빠름
    - OS가 새 데이터를 저장할 공간을 찾을 필요가 없기 때문
    - 새 데이터는 항상 스택의 가장 위에 추가됨
    - 힙에 공간을 할당하는 것은 상대적으로 더 많은 작업 필요
    - OS가 먼저 데이터를 저장할 충분히 큰 공간을 찾은 후 다음 할당 작업을 위한 예약 작업을 수행해야 하는 이유
  - 힙에 저장된 데이터에 대한 접근은 스택에 저장된 데이터에 접근하는 것보다 느림
    - 포인터를 따라가야 하기 때문
    - 현대의 프로세서들은 메모리 사이를 왔다 갔다 하는 일이 더 적을수록 더 빠르게 동작
    - 멀리 떨어진 데이터(Heap)를 처리할 때보다는 다른 데이터에 가까운 데이터(Stack)를 처리할 때 더 능률적으로 동작
    - 큰 공간을 힙 메모리에 할당하려면 어느 정도 시간이 필요
  - 코드에서 함수 호출 시 이 함수에는 여러 값들이 전달되며, 이 값들은 함수의 로컬 변수에 할당되어 스택에 저장됨
    - 함수의 실행 완료 시 이 값들은 스택에서 제거됨
  - 코드의 어느 부분이 힙 메모리에 저장된 데이터를 사용하는지 추적하고 힙에 저장되는 데이터의 중복을 최소화해 사용하지 않는 데이터를 힙 메모리에서 제거하면 메모리 부족 문제를 해소할 수 있음
    - 러스트의 소유권 기능이 이 문제를 해결하려는 방법
    - 소유권은 힙 데이터를 관리하려고 존재하는 것

#### **🤔 소유권 규칙**
- 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있음
- 특정 시점에 값의 소유자는 단 하나뿐임
- 소유자가 범위를 벗어나면 그 값은 제거됨

#### **🤔 변수의 범위(scope)**
```rust
{ // 변수 s를 아직 선언하지 않았으므로 변수가 유효하지 않음
  let s = "Hello world!"; // 변수 s는 이 지점부터 유효함
  // 변수 s를 사용한 동작 수행
} // 범위를 벗어나므로 변수 s는 이제 유효하지 않음
```
- _변수 s는 프로그램 내 하드코딩한 문자열값인 문자열 리터럴을 참조함_
- **핵심 1.** 변수가 범위 안으로 들어오면 유효함
- **핵심 2.** 변수는 범위를 벗어나기 전까지 유효함

#### **🤔 String 타입**
- 문자열 리터럴은 텍스트를 다루어야 하는 모든 경우에 적합한 방법은 아님
  - **이유 1.** 문자열은 불변(immutable)
  - **이유 2.** 코드를 작성하는 시점에 필요한 모든 문자열값을 알 수 없음
- 사용자가 입력한 값을 저장해야 한다면 `String` 타입 사용
  - 힙에 할당되므로 컴파일 시점에 알 수 없는 크기의 문자열 저장 가능
  - `from` 함수를 사용하면 문자열 리터럴로 `String` 인스턴스 생성 가능
    - `let s = String::from("Hello world!");`
    - 두 개의 콜론 `::` 은 `from` 함수를 `String` 타입의 이름 공간으로 제한하여 string_from 같은 이름 대신 더 명료한 이름을 사용하기 위함
- `String` 타입은 _mutable_, 리터럴은 _immutable_
  ```rust
  fn main() {
      let mut s = String::from("Hello");
      s.push_str(" Rust world!!");
      println!("{}", s);
  }
  // Result
  // Hello Rust world!!
  ```
  - `push_str()` 은 `String` 인스턴스에 리터럴을 결합

#### **🤔 메모리와 할당**
- 문자열 리터럴은 컴파일 시점에 문자열 내용을 이미 알고 있으므로 텍스트를 최종 실행할 수 있는 형태로 직접 하드코딩할 수 있음
  - 빠르고 효율적이지만 불변이라는 사실에서 비롯된 것
- 컴파일 시점에 그 길이를 미리 알 수 없거나 프로그램 실행 중에 길이가 변경되는 문자열은 그 문자열이 사용할 메모리를 바이너리 형태로 미리 변환이 불가능함
- `String` 타입은 컴파일 시점에 알 수 없는 내용을 저장하기 위해 힙 메모리에 일정 부분의 메모리를 할당
  - **절차 1.** 해당 메모리는 반드시 런타임에 OS에 요청해야 함
  - **절차 2.** `String` 타입의 사용이 완료된 후에는 이 메모리를 OS에 다시 돌려줄 방법 필요
- **절차 1**은 개발자가 처리
  - `String::from` 함수 호출 시 이 함수가 필요한 메모리를 요청함
- **절차 2**는 조금 다름
  - GC를 사용하는 언어들은 GC가 처리하므로 직접 처리할 필요가 없음
  - GC가 없는 언어들은 메모리를 더 이상 사용하지 않는 시점을 인지하여 해당 메모리를 돌려주는 작업을 직접 처리해야 함
    - 메모리를 너무 일찍 해제함 => 유효하지 않은 변수 발생 가능성
    - 메모리 해제를 두 번 실행 => 버그 유발
    - **_정확히 한 번 씩의 할당(allocate)과 해제(free) 작업을 요함_**
- 변수가 범위를 벗어나면 러스트는 `drop` 이라는 이름의 특별 함수 호출
  - 닫는 중괄호를 만나면 `drop` 함수 자동 호출
  - **_C++에서는 어떤 항목의 수명주기 마지막에 자원을 해제하는 패턴을 `초기화에 의한 자원 획득(RAII, Resource Acquisition Is Initialization)` 이라고 칭함._**
    - 러스트의 `drop` 함수는 `RAII` 패턴과 유사

#### **1️⃣ 변수와 데이터가 상호작용하는 방식 : 이동(Move)**
```rust
fn main() {
    let x = 6;
    let y = x;

    println!("{} {}", x, y);
}
// Result
// 6 6
```
- 값 6을 변수 x에 대입 후 변수 x 값의 복사본을 변수 y에 대입
- 정수는 고정 크기의 단순한 값이기에 6이라는 값 두 개가 스택에 저장됨

```rust
fn main() {
    let s1 = String::from("Hello!");
    let s2 = s1;

    println!("{}\n{}", s1, s2);
}
// Result
// error[E0382]: borrow of moved value: `s1`
```
- 정수 코드와 같은 방식으로 작동하지 않고 오류 발생
- `String` 타입은 문자열 콘텐츠를 저장하고 있는 메모리에 대한 포인터, 길이(length), 용량(capacity) 세 부분으로 구성되며 스택에 저장됨
- [변수 s1]
  | 이름 | 값 |
  | --- | -- |
  | 포인터 | contents |
  | 길이 | 6 |
  | 용량 | 6 |
  - 길이(length) : `String` 타입의 콘텐츠가 현재 어느 정도의 메모리를 사용 중인지 바이트 단위로 표현한 값
  - 용량(capacity) : `String` 타입이 OS로부터 할당받은 총 메모리를 바이트 단위로 표현한 값
- [변수 s1의 포인터가 가리키는 실제 contects]
  | 인덱스 | 값 |
  | -- | -- |
  | 0 | H |
  | 1 | e |
  | 2 | l |
  | 3 | l |
  | 4 | o |
  | 5 | ! |
- 변수 s1을 s2에 대입하면 `String` 타입의 데이터가 복사됨
  - 포인터가 가리키는 힙 메모리의 실제 데이터가 아닌 문자열에 대한 포인터와 길이, 용량이 스택에 복사됨
- 변수 s2와 s1이 범위를 벗어나면 두 변수가 모두 같은 메모리를 해제하려 함
  - `이중 해제 에러(double free error)` 발생
    - 메모리 안전성 버그 중 하나
  - 메모리를 두 번 해제하는 것은 메모리의 불순화(corruption)를 일으키며, 잠재적으로 보안상의 취약점이 될 수 있음
- 러스트는 할당된 메모리를 복사하는 대신 변수 s1이 더 이상 유효하지 않다고 판단함
  - 때문에 변수 s1이 범위를 벗어날 때 메모리를 해제할 필요가 없음
  - **유효하지 않은 참조 사용, 에러코드 `[E0382]` 의 이유**
- 얕은 복사(shallow copy)와 깊은 복사(deep copy) 중 실제 데이터를 복사하지 않고 포인터와 길이, 용량만을 복사하는 동작이 얕은 복사와 유사할 것으로 생각됨
  - **하지만,** 러스트는 첫 번째 변수를 **_무효화_** 해버리므로 얕은 복사가 아닌 이동(move)이라고 칭함
- 이동이 일어나면 두 번째 변수만 유효하기 때문에 `이중 해제 에러` 를 해결할 수 있음
- 러스트는 절대 자동으로 데이터에 대한 deep copy를 수행하지 않음

#### **2️⃣ 변수와 데이터가 상호작용하는 방식 : 복제(Clone)**
- 스택 메모리가 아닌 힙 메모리에 저장된 데이터를 복사하려면 `clone` 공통 메서드를 사용하면 됨
- `clone` 메서드는 호출 시 어떤 추가 코드가 실행됨
- 복사하는 메모리의 크기에 따라 무거운 작업이 될 수 있음

#### **3️⃣ 스택 전용 데이터 : 복사(Copy)**
- 정수형 같은 타입은 컴파일 시점에 이미 그 크기를 알 수 있으며, 온전히 스택에 저장되기 때문에 실제 값을 복사해도 무관함
  - 변수 무효화의 이유가 없음
- 러스트는 스택에 저장되는 타입에 적용할 수 있는 `Copy` trait를 제공
- `Copy` trait이 적용되어 있다면 이전 변수를 새 변수에 할당해도 무효화되지 않음
- 다만, 어떤 타입, 혹은 그 타입의 일부에 `Drop` trait이 적용되어 있다면 `Copy` trait를 적용할 수 없음
  - 범위를 벗어나는 시점에 뭔가 특별한 처리가 필요한 타입에 `Copy` trait를 적용하려고 하면 컴파일 에러 발생
- 통상적으로 단순한 스칼라 값에는 `Copy` trait가 적용되어 있으며, 할당이 필요하거나 특정 형태의 자원에도 적용되어 있음

#### **🤔 소유권과 함수**
- 값을 함수에 전달함 = 값을 변수에 대입함
  - 변수를 함수에 전달하면 대입과 마찬가지로 값의 이동이나 복사가 이루어짐
```rust
fn main() {
    let s = String::from("Hello!"); // 변수 s 생성
    takes_ownership(s); // 변수 s 함수 이동
} // 변수 s가 범위를 벗어났지만 takes_ownership 함수 내로 이동했기 때문에 아무런 일이 일어나지 않음

fn takes_ownership(receive_s: String) { // 변수 receive_s 생성
    println!("{}", receive_s);
} // 범위 벗어나며 drop 함수가 호출되며 receive_s 변수가 사용하던 메모리 해제됨
// Result
// Hello!
```
- 만약 `main` 함수 내에서 변수 s의 이동이 일어난 후 사용 요청을 하면 에러가 발생함

```rust
fn main() {
    let x = 6; // 변수 x 생성
    makes_copy(x); // 변수 x 함수 이동
    println!("{}", x); // i32 타입은 복사를 수행하므로 변수 x는 여전히 유효함
}

fn makes_copy(clone_x: i32) { // 변수 clone_x 생성
    println!("{}", clone_x);
}
// Result
// 6
// 6
```

#### **🤔 리턴값과 볌위**
- 리턴값도 소유권을 이전함
```rust
fn main() {
    let s1 = give_ownership(); // give_ownership의 리턴값이 s1으로 옮겨짐
    let s2 = String::from("Rust!"); // s2 생성
    println!("{}", s2);
    
    let s3 = take_and_give(s2); // s2 함수 이동 후 리턴값 s3로 옮겨짐

    println!("{} {}", s1, s3);
} // s1, s3 drop 함수 호출로 메모리 해제
// s2는 함수로 이동됐기에 아무 일도 일어나지 않음

fn give_ownership() -> String {
    let s = String::from("Rust!!"); // s 생성
    s // s 리턴
}

fn take_and_give(s: String) -> String { // s 생성
    s // s 리턴
}
```
- 변수의 소유권은 매번 같은 패턴을 따름
  - 값을 다른 변수에 할당하면 소유권이 옮겨짐
  - 힙 메모리에 저장된 변수의 데이터는 소유권이 다른 변수로 옮겨지지 않았다면 범위를 벗어날 때 `drop` 함수에 의해 제거됨