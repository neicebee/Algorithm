# 🦀 Rust Day 9

## **🏳️ Understanding Ownership**
- 소유권은 러스트의 독특한 기능 중 하나
- 가비지 콜렉터(Garbage Collector)에 의존하지 않고도 메모리 안정성을 보장하려는 러스트만의 해법
  - `Garbage Collection` (통칭 GC)
    - 메모리 관리 방법 중 하나로, 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아내어 해제하는 기능
    - **_시스템에서 가비지 컬렉션을 수행하는 부분을 컬렉터라 칭함_**
    - 보통 쓰레기 수집 기능을 채택한 언어의 경우 프로그래머에게 직접적인 메모리 할당과 해제를 하게 하는 대신에 쓰레기 수집기에서 제공하는 할당과 해제를 사용하게 하여 프로그램이 실행되는 중간중간에 쓸모가 없어진 메모리, 즉 쓰레기를 알아서 수집함

### **1️⃣ 소유권이란?**
- **소유권은 러스트의 핵심 기능. 언어 전체에 깊이 관여하고 있는 개념**
- 프로그램들의 메모리 관리 방법
  - 가비지 콜렉터를 이용해 메모리를 관리하는 언어
  - 프로그래머가 명시적으로 메모리를 할당하고 해제해 주어야 하는 언어
- 러스트는 제 3의 방법 사용
  - 메모리는 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로 이루어진 `소유권 시스템` 에 의해 관리됨
  - 때문에 소유권과 관련된 기능은 프로그램의 실행 성능에 아무런 영향을 미치지 않음
  - _러스트와 소유권 시스템의 규칙에 익숙해질수록 더 안전하며 효율적인 코드 작성 가능_
- **스택(Stack) 메모리와 힙(Heap) 메모리**
  - 러스트 같은 시스템 프로그래밍 언어 환경에서는 값이 스택 메모리에 저장되었는지 힙 메모리에 저장되었는지에 따라 언어의 동작이나 의사결정에 큰 영향을 미침
  - 스택과 힙은 코드가 런타임에 활용하는 메모리의 일부이며 각자 다른 방법으로 데이터를 구성함
  - **스택(Stack)**
    - 유입된 순서대로 데이터 저장
    - 읽을 때는 유입된 반대 순서
      - 즉, 마지막에 들어온 값을 가장 먼저 읽는 구조(LIFO, Last In, First Out)
    - 쌓인 데이터 중간에 다른 데이터를 삽입하거나 꺼내는 동작은 허용되지 않음
    - 스택에 새로운 데이터를 쌓는 동작 => `push`
    - 스택의 제일 위에서 데이터를 꺼내는 동작 => `pop`
    - 스택에 저장하는 모든 데이터는 고정된 크기를 가져야 함
  - **힙(Heap)**
    - 컴파일 시점에 크기를 알 수 없는 데이터나 런타임에 동적으로 크기가 변하는 데이터는 힙에 저장
    - 스택에 비해 복잡함
    - 힙에 데이터를 넣는 동작은 메모리의 일정 공간을 할애할 것을 요청하는 것 => OS는 힙 메모리에서 일정 공간을 찾아 사용중인 메모리로 표시한 후, 해당 메모리의 주솟값인 포인터(pointer)를 넘겨줌
    - 위의 과정을 `힙 메모리 할당(allocating on the heap)` 또는 단순히 `할당(allocating)` 이라고 칭함
    - **_스택에 값을 푸시하는 동작에는 할당이 발생하지 않음_**
      - 포인터는 이미 크기가 고정된 값이므로 포인터는 스택에 저장할 수 있지만, 실제 포인터가 가리키는 데이터가 필요할 때는 포인터가 가리키는 메모리를 따라가야 함
  - 스택에 데이터를 푸시하는 것이 힙에 할당하는 것보다 빠름
    - OS가 새 데이터를 저장할 공간을 찾을 필요가 없기 때문
    - 새 데이터는 항상 스택의 가장 위에 추가됨
    - 힙에 공간을 할당하는 것은 상대적으로 더 많은 작업 필요
    - OS가 먼저 데이터를 저장할 충분히 큰 공간을 찾은 후 다음 할당 작업을 위한 예약 작업을 수행해야 하는 이유
  - 힙에 저장된 데이터에 대한 접근은 스택에 저장된 데이터에 접근하는 것보다 느림
    - 포인터를 따라가야 하기 때문
    - 현대의 프로세서들은 메모리 사이를 왔다 갔다 하는 일이 더 적을수록 더 빠르게 동작
    - 멀리 떨어진 데이터(Heap)를 처리할 때보다는 다른 데이터에 가까운 데이터(Stack)를 처리할 때 더 능률적으로 동작
    - 큰 공간을 힙 메모리에 할당하려면 어느 정도 시간이 필요
  - 코드에서 함수 호출 시 이 함수에는 여러 값들이 전달되며, 이 값들은 함수의 로컬 변수에 할당되어 스택에 저장됨
    - 함수의 실행 완료 시 이 값들은 스택에서 제거됨
  - 코드의 어느 부분이 힙 메모리에 저장된 데이터를 사용하는지 추적하고 힙에 저장되는 데이터의 중복을 최소화해 사용하지 않는 데이터를 힙 메모리에서 제거하면 메모리 부족 문제를 해소할 수 있음
    - 러스트의 소유권 기능이 이 문제를 해결하려는 방법
    - 소유권은 힙 데이터를 관리하려고 존재하는 것

#### **🤔 소유권 규칙**
- 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있음
- 특정 시점에 값의 소유자는 단 하나뿐임
- 소유자가 범위를 벗어나면 그 값은 제거됨

#### **🤔 변수의 범위(scope)**
```rust
{ // 변수 s를 아직 선언하지 않았으므로 변수가 유효하지 않음
  let s = "Hello world!"; // 변수 s는 이 지점부터 유효함
  // 변수 s를 사용한 동작 수행
} // 범위를 벗어나므로 변수 s는 이제 유효하지 않음
```
- _변수 s는 프로그램 내 하드코딩한 문자열값인 문자열 리터럴을 참조함_
- **핵심 1.** 변수가 범위 안으로 들어오면 유효함
- **핵심 2.** 변수는 범위를 벗어나기 전까지 유효함

#### **🤔 String 타입**
- 문자열 리터럴은 텍스트를 다루어야 하는 모든 경우에 적합한 방법은 아님
  - **이유 1.** 문자열은 불변(immutable)
  - **이유 2.** 코드를 작성하는 시점에 필요한 모든 문자열값을 알 수 없음
- 사용자가 입력한 값을 저장해야 한다면 `String` 타입 사용
  - 힙에 할당되므로 컴파일 시점에 알 수 없는 크기의 문자열 저장 가능
  - `from` 함수를 사용하면 문자열 리터럴로 `String` 인스턴스 생성 가능
    - `let s = String::from("Hello world!");`
    - 두 개의 콜론 `::` 은 `from` 함수를 `String` 타입의 이름 공간으로 제한하여 string_from 같은 이름 대신 더 명료한 이름을 사용하기 위함
- `String` 타입은 _mutable_, 리터럴은 _immutable_
  ```rust
  fn main() {
      let mut s = String::from("Hello");
      s.push_str(" Rust world!!");
      println!("{}", s);
  }
  // Result
  // Hello Rust world!!
  ```
  - `push_str()` 은 `String` 인스턴스에 리터럴을 결합

#### **🤔 메모리와 할당**
- 문자열 리터럴은 컴파일 시점에 문자열 내용을 이미 알고 있으므로 텍스트를 최종 실행할 수 있는 형태로 직접 하드코딩할 수 있음
  - 빠르고 효율적이지만 불변이라는 사실에서 비롯된 것
- 컴파일 시점에 그 길이를 미리 알 수 없거나 프로그램 실행 중에 길이가 변경되는 문자열은 그 문자열이 사용할 메모리를 바이너리 형태로 미리 변환이 불가능함
- `String` 타입은 컴파일 시점에 알 수 없는 내용을 저장하기 위해 힙 메모리에 일정 부분의 메모리를 할당
  - **절차 1.** 해당 메모리는 반드시 런타임에 OS에 요청해야 함
  - **절차 2.** `String` 타입의 사용이 완료된 후에는 이 메모리를 OS에 다시 돌려줄 방법 필요
- **절차 1**은 개발자가 처리
  - `String::from` 함수 호출 시 이 함수가 필요한 메모리를 요청함
- **절차 2**는 조금 다름
  - GC를 사용하는 언어들은 GC가 처리하므로 직접 처리할 필요가 없음
  - GC가 없는 언어들은 메모리를 더 이상 사용하지 않는 시점을 인지하여 해당 메모리를 돌려주는 작업을 직접 처리해야 함
    - 메모리를 너무 일찍 해제함 => 유효하지 않은 변수 발생 가능성
    - 메모리 해제를 두 번 실행 => 버그 유발
    - **_정확히 한 번 씩의 할당(allocate)과 해제(free) 작업을 요함_**
- 변수가 범위를 벗어나면 러스트는 `drop` 이라는 이름의 특별 함수 호출
  - 닫는 중괄호를 만나면 `drop` 함수 자동 호출
  - **_C++에서는 어떤 항목의 수명주기 마지막에 자원을 해제하는 패턴을 `초기화에 의한 자원 획득(RAII, Resource Acquisition Is Initialization)` 이라고 칭함._**
    - 러스트의 `drop` 함수는 `RAII` 패턴과 유사

#### **1️⃣ 변수와 데이터가 상호작용하는 방식 : 이동(Move)**
```rust
fn main() {
    let x = 6;
    let y = x;

    println!("{} {}", x, y);
}
// Result
// 6 6
```
- 값 6을 변수 x에 대입 후 변수 x 값의 복사본을 변수 y에 대입
- 정수는 고정 크기의 단순한 값이기에 6이라는 값 두 개가 스택에 저장됨

```rust
fn main() {
    let s1 = String::from("Hello!");
    let s2 = s1;

    println!("{}\n{}", s1, s2);
}
// Result
// error[E0382]: borrow of moved value: `s1`
```
- 정수 코드와 같은 방식으로 작동하지 않고 오류 발생
- `String` 타입은 문자열 콘텐츠를 저장하고 있는 메모리에 대한 포인터, 길이(length), 용량(capacity) 세 부분으로 구성되며 스택에 저장됨
- [변수 s1]
  | 이름 | 값 |
  | --- | -- |
  | 포인터 | contents |
  | 길이 | 6 |
  | 용량 | 6 |
  - 길이(length) : `String` 타입의 콘텐츠가 현재 어느 정도의 메모리를 사용 중인지 바이트 단위로 표현한 값
  - 용량(capacity) : `String` 타입이 OS로부터 할당받은 총 메모리를 바이트 단위로 표현한 값
- [변수 s1의 포인터가 가리키는 실제 contects]
  | 인덱스 | 값 |
  | -- | -- |
  | 0 | H |
  | 1 | e |
  | 2 | l |
  | 3 | l |
  | 4 | o |
  | 5 | ! |
- 변수 s1을 s2에 대입하면 `String` 타입의 데이터가 복사됨
  - 포인터가 가리키는 힙 메모리의 실제 데이터가 아닌 문자열에 대한 포인터와 길이, 용량이 스택에 복사됨
- 변수 s2와 s1이 범위를 벗어나면 두 변수가 모두 같은 메모리를 해제하려 함
  - `이중 해제 에러(double free error)` 발생
    - 메모리 안전성 버그 중 하나
  - 메모리를 두 번 해제하는 것은 메모리의 불순화(corruption)를 일으키며, 잠재적으로 보안상의 취약점이 될 수 있음
- 러스트는 할당된 메모리를 복사하는 대신 변수 s1이 더 이상 유효하지 않다고 판단함
  - 때문에 변수 s1이 범위를 벗어날 때 메모리를 해제할 필요가 없음
  - **유효하지 않은 참조 사용, 에러코드 `[E0382]` 의 이유**
- 얕은 복사(shallow copy)와 깊은 복사(deep copy) 중 실제 데이터를 복사하지 않고 포인터와 길이, 용량만을 복사하는 동작이 얕은 복사와 유사할 것으로 생각됨
  - **하지만,** 러스트는 첫 번째 변수를 **_무효화_** 해버리므로 얕은 복사가 아닌 이동(move)이라고 칭함
- 이동이 일어나면 두 번째 변수만 유효하기 때문에 `이중 해제 에러` 를 해결할 수 있음
- 러스트는 절대 자동으로 데이터에 대한 deep copy를 수행하지 않음

#### **2️⃣ 변수와 데이터가 상호작용하는 방식 : 복제(Clone)**
- 스택 메모리가 아닌 힙 메모리에 저장된 데이터를 복사하려면 `clone` 공통 메서드를 사용하면 됨
- `clone` 메서드는 호출 시 어떤 추가 코드가 실행됨
- 복사하는 메모리의 크기에 따라 무거운 작업이 될 수 있음

#### **3️⃣ 스택 전용 데이터 : 복사(Copy)**
- 정수형 같은 타입은 컴파일 시점에 이미 그 크기를 알 수 있으며, 온전히 스택에 저장되기 때문에 실제 값을 복사해도 무관함
  - 변수 무효화의 이유가 없음
- 러스트는 스택에 저장되는 타입에 적용할 수 있는 `Copy` trait를 제공
- `Copy` trait이 적용되어 있다면 이전 변수를 새 변수에 할당해도 무효화되지 않음
- 다만, 어떤 타입, 혹은 그 타입의 일부에 `Drop` trait이 적용되어 있다면 `Copy` trait를 적용할 수 없음
  - 범위를 벗어나는 시점에 뭔가 특별한 처리가 필요한 타입에 `Copy` trait를 적용하려고 하면 컴파일 에러 발생
- 통상적으로 단순한 스칼라 값에는 `Copy` trait가 적용되어 있으며, 할당이 필요하거나 특정 형태의 자원에도 적용되어 있음

#### **🤔 소유권과 함수**
- 값을 함수에 전달함 = 값을 변수에 대입함
  - 변수를 함수에 전달하면 대입과 마찬가지로 값의 이동이나 복사가 이루어짐
```rust
fn main() {
    let s = String::from("Hello!"); // 변수 s 생성
    takes_ownership(s); // 변수 s 함수 이동
} // 변수 s가 범위를 벗어났지만 takes_ownership 함수 내로 이동했기 때문에 아무런 일이 일어나지 않음

fn takes_ownership(receive_s: String) { // 변수 receive_s 생성
    println!("{}", receive_s);
} // 범위 벗어나며 drop 함수가 호출되며 receive_s 변수가 사용하던 메모리 해제됨
// Result
// Hello!
```
- 만약 `main` 함수 내에서 변수 s의 이동이 일어난 후 사용 요청을 하면 에러가 발생함

```rust
fn main() {
    let x = 6; // 변수 x 생성
    makes_copy(x); // 변수 x 함수 이동
    println!("{}", x); // i32 타입은 복사를 수행하므로 변수 x는 여전히 유효함
}

fn makes_copy(clone_x: i32) { // 변수 clone_x 생성
    println!("{}", clone_x);
}
// Result
// 6
// 6
```

#### **🤔 리턴값과 볌위**
- 리턴값도 소유권을 이전함
```rust
fn main() {
    let s1 = give_ownership(); // give_ownership의 리턴값이 s1으로 옮겨짐
    let s2 = String::from("Rust!"); // s2 생성
    println!("{}", s2);
    
    let s3 = take_and_give(s2); // s2 함수 이동 후 리턴값 s3로 옮겨짐

    println!("{} {}", s1, s3);
} // s1, s3 drop 함수 호출로 메모리 해제
// s2는 함수로 이동됐기에 아무 일도 일어나지 않음

fn give_ownership() -> String {
    let s = String::from("Rust!!"); // s 생성
    s // s 리턴
}

fn take_and_give(s: String) -> String { // s 생성
    s // s 리턴
}
```
- 변수의 소유권은 매번 같은 패턴을 따름
  - 값을 다른 변수에 할당하면 소유권이 옮겨짐
  - 힙 메모리에 저장된 변수의 데이터는 소유권이 다른 변수로 옮겨지지 않았다면 범위를 벗어날 때 `drop` 함수에 의해 제거됨

```rust
fn main() {
    let s1 = String::from("Hello!");
    let (s2, len) = string_length(s1);

    println!("'{}' 의 길이 : {}", s2, len);
}

fn string_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}
// Result
// 'Hello!' 의 길이 : 6
```
- 튜플을 이용해 매개변수의 소유권을 실제 함수의 리턴값과 함께 다시 리턴하는 코드
  - 해당 코드와 같이 모든 함수가 소유권을 확보하고 다시 리턴하는 방식은 다소 효율적인 방법이 아님
- **러스트는 `참조(references)` 라는 개념으로 함수에 값을 이전할 때 소유권을 이전하지 않을 수 있음**

### **2️⃣ 참조와 대여**
- 튜플을 사용하여 값의 소유권을 가져오는 대신, 매개변수로 객체의 참조를 전달할 수 있음
- `&(ampersands)` 기호가 `참조(references)` 이며, 소유권을 가져오지 않고 값을 참조할 수 있음
  - 참조의 반대는 역참조 연산자인 `*` 에 의해 동작하는 `역참조(dereferencing)`
```rust
fn main() {
    let s1 = String::from("Hello!");
    let length = get_length(&s1);

    println!("'{}' 의 길이 : {}", s1, length);
}

fn get_length(s: &String) -> usize {
    s.len()
}
// Result
// 'Hello!' 의 길이 : 6
```
- 매개변수로 객체의 참조를 전달받는 코드
- [`String` 타입의 변수 s1을 가리키는 `&String s`]
  | 이름 | 값 |
  | -- | ---- |
  | 포인터 | 스택 메모리에 위치한 s1 |
- 참조는 소유권을 갖고 있지 않기에 참조가 가리키는 값은 참조가 범위를 벗어나더라도 `drop` 함수가 호출되지 않음
- 함수 매개변수로 참조를 전달하는 것을 `대여(borrowing)` 라고 칭함
- 대여한 변수는 수정이 불가능함
  - 변수가 기본적으로 불변인 것처럼 참조도 기본적으로 불변임

#### **🤔 가변 참조**
- 변수에 `mut` keywork 추가 후 가변 참조를 전달하면 값 변경이 가능함
- 가변 참조에도 제약이 있음
  - 특정 범위 내의 특정 데이터에 대한 가변 참조는 **오직 한 개**만 존재해야 함
  - 제약 덕분에 러스트는 `데이터 경합(data races)` 을 컴파일 시점에 방지 가능
  - 데이터 경합은 `경합 조건(race condition)` 과 유사하며 주로 다음의 세 가지 동작으로 인해 발생
    - **동작 1.** 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근할 때
    - **동작 2.** 최소한 하나의 포인터가 데이터를 쓰기 위해 사용될 때
    - **동작 3.** 데이터에 대한 접근을 동기화 할 수 있는 메커니즘이 없을 때
  - 데이터 경합은 예측할 수 없는 결과를 유발하며, 런타임에 원인을 파악하고 수정하기가 매우 어려움
    - **_러스트는 컴파일 허용을 하지 않음으로써 문제를 예방함_**
  - 중괄호를 사용하면 새 범위가 생성되는 것이므로 동시에 활용은 불가능하지만, 여러 개의 가변 참조를 활용할 수 있음
- 불변 참조를 이미 사용 중일 때 가변 참조를 생성할 수 없음
  - 불변 참조를 생성했다면 그 값을 변경해서는 안 되기 때문
  - 데이터를 읽는 동작은 다른 사용자가 데이터를 읽는 동작에 아무런 영향을 주지 않으므로 불변 참조는 여러 개 생성해도 무방함

#### **🤔 죽은 참조**
- 포인터를 사용하는 언어는 죽은 포인터로 인해 에러가 발생하기 쉬움
- **죽은 포인터**
  - 이미 해제되어 다른 정보를 저장하도록 변경된 메모리를 계속해서 참조하는 포인터
- 러스트는 죽은 참조가 발생하지 않도록 컴파일러가 보장해 줌
  - 어떤 데이터에 대한 참조를 생성하면 컴파일러가 해당 데이터에 대한 참조를 실행하기에 앞서 데이터가 범위를 벗어나지 않았는지 확인함
  - 변수가 함수 내에서 생성되었고 함수의 실행이 종료되는 시점에 변수의 메모리가 해제됨
  - 함수가 해제된 메모리에 대한 참조를 리턴하려고 시도하면 참조가 가리키는 메모리에 유효하지 않은 값이 보관되어 있음을 확인 후 접근을 절대 허용하지 않음
  - 함수 내에서 변수의 참조가 아닌 변수를 직접 리턴하면 소유권이 이전되기에 정상 작동함

#### **🤔 참조에 대한 규칙**
- 어느 한 시점에 코드는 하나의 가변 참조 또는 여러 개의 불변 참조를 생성할 수 있지만, 둘 모두는 생성할 수 없음
- 참조는 항상 유효해야 함

### **3️⃣ 슬라이스 타입**
- 슬라이스도 소유권을 갖지 않는 타입
- 슬라이스 사용 시 컬렉션 전체가 아니라 컬렉션 내의 연속된 요소들 참조 가능
- **전달될 문자열에서 첫 번째 단어만 리턴하는 함수** 작성
  - _문자열에 공백이 없다면 전체 문자열이 한 단어일 것이므로 전체 문자열 리턴_
  - 함수의 리턴값이 `usize` 타입인 단어의 끝에 해당하는 문자의 인덱스라면 `String` 타입인 전달될 문자열이 변경되었을 경우 논리적 오류를 일으킴

#### **🤔 문자열 슬라이스**
- `문자열 슬라이스(string slices)` 는 `String` 의 일부에 대한 참조
- `[starting_index..ending_index]` 로 범위를 지정하여 슬라이스 생성 가능
- 내부적으로 슬라이스는 시작 위치로부터 슬라이스의 길이, `ending_index` 에서 `starting_index` 를 뺀 만큼의 데이터를 저장하는 구조체
- **(1)** 인덱스 0부터 탐색 시 앞의 값 생략 가능
- **(2)** 마지막 인덱스까지 탐색 시 뒤의 값 생략 가능
- **(3)** 전체를 슬라이스로 참조 시 양쪽의 값 생략 가능
- _파이썬의 슬라이싱과 유사_
- **_문자열 슬라이스의 범위 인덱스는 반드시 유효한 UTF-8에 해당하는 문자를 추출해야 함_**
- **문자열 리터럴은 슬라이스**
  - `let s = "Hello, world!";`
  - 변수 s의 타입은 `&str`
    - 바이너리의 어느 한 지점을 가리키는 슬라이스이기에 문자열 리터럴은 항상 불변 => `&str` 은 불변 참조
  - 문자열 리터럴은 이미 문자열 슬라이스이기 때문에 슬라이스 문법 없이도 정상 동작함
- **문자열 슬라이스 매개변수**
  - `String` 타입에 대한 참조 대신 문자열 슬라이스를 함수의 매개변수로 사용하면 같은 기능을 유지하면서도 더 보편적이고 유용한 API를 디자인할 수 있음

```rust
fn main() {
    let s_words = String::from("little bottle of water");
    let l_words = "Chips! tomato and lettuce";
    let s_f_word = find_first_word(&s_words[..]);
    let l_f_word = find_first_word(l_words);

    println!("{}", s_f_word);
    println!("{}", l_f_word);
}

fn find_first_word(s: &str) -> &str{
    let byte_s = s.as_bytes();

    for (i, &item) in byte_s.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }
    s
}
// Result
// little
// Chips!
```
- 위의 내용들을 학습한 후 최종 코드
- `as_bytes` 메서드 : 문자열을 바이트 배열로 변환
- `iter` 메서드 : 바이트 배열의 `반복자(iterator)` 생성
- `enumerate` 메서드 : `iterator` 의 결과를 감싸서 각 원소를 튜플 형태로 반환
  - `(index, reference to that element)`

#### **🤔 다른 타입의 슬라이스**
```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```
- 해당 슬라이스는 `&[i32]` 타입
- 문자열 슬라이스와 마찬가지로 첫 번째 요소와 길이에 대한 참조를 저장하는 방식으로 작동함
- 이런 형태의 슬라이스는 모든 종류의 컬렉션에 대해 활용 가능

## **Summary**
- 소유권, 대여, 슬라이스는 러스트 프로그램의 컴파일 시점에 메모리 안전성을 확보하기 위한 개념들
- 다른 프로그래밍 언어들과 같은 방법으로 메모리 사용에 대한 완전한 통제권을 개발자에게 제공
- 데이터의 소유자가 범위를 벗어날 때 자동으로 해당 데이터의 소유권을 해제함으로써 메모리의 안전한 사용이나 디버깅을 위한 추가 코드를 작성할 필요가 없음