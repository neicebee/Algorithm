# 🦀 Rust Day 24

## **🏳️ Smart Pointers**
- 포인터(pointer) : 메모리에 주소를 가지고 있는 변수를 일컫는 보편적인 개념
- 러스트의 참조
  - & 기호 이용해 지정
  - 변수가 가리키는 값을 대여함
  - 별도의 오버헤드 없음
- 스마트 포인터(smart pointer) : 포인터처럼 동작할 뿐만 아니라 추가적인 메타데이터와 기능을 포함하는 데이터 구조
  - 참조는 데이터를 대여할 수만 있지만, 스마트 포인터는 대부분 포인터가 가리키는 데이터를 소유함
  - `String` 과 `Vec<T>` 타입 모두 메모리를 소유하며 데이터를 갱신할 수 있으므로 스마트 포인터
    - 메타데이터(저장 용량 등)와 추가 기능이나 보장(String은 모든 데이터가 항상 유효한 UTF-8 문자임을 보장)을 제공
  - 스마트 포인터는 주로 구조체를 이용해 구현함
    - 일반 구조체와 달리 Deref와 Drop 트레이트를 구현함
    - Deref : 스마트 포인터 구조체가 참조처럼 동작해서 참조나 스마트 포인터를 같은 방법으로 다룰 수 있도록 지원
    - Drop : 스마트 포인터의 인스턴스가 범위를 벗어날 때 임의의 코드를 실행하도록 지원

### **1️⃣ `Box<T>` 를 이용해 힙 메모리의 데이터 참조하기**
- 박스(`Box<T>`) : 가장 직관적인 스마트 포인터 
  - 데이터를 힙 메모리에 저장함
  - 스택에는 힙 데이터를 가리키는 포인터만 저장함
  - 박스를 사용하는 예
    - 컴파일타임에 크기를 알 수 없는 타입을 정확한 크기가 필요한 상황에 사용하려고 할 때
    - 데이터의 크기가 커서 데이터를 복제하지 않고 소유권을 이전하고 싶을 때
    - 특정 타입이 아니라 특정 트레이트를 구현하는 타입의 값을 소유하고자 할 때

#### **🤔 `Box<T>` 를 이용해 힙 메모리에 데이터 저장하기**

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```
- 박스를 이용해 i32값을 힙 메모리에 저장
  - 소유된 값과 마찬가지로 박스가 범위를 벗어나면 메모리가 해제됨(박스와 박스가 가리키는 데이터의 메모리가 모두 해제)

<br>

#### **🤔 박스를 이용해 재귀 타입 활용하기**
- 재귀 타입(recursive type) : 같은 타입의 다른 값을 자신의 일부에 포함하는 값
  - 값을 중첩하는 것은 이론적으로 무한할 수 있어서 러스트는 재귀 타입의 값을 저장하는 데 필요한 공간을 판단할 수 없음
  - 박스의 크기는 정해져 있으므로 재귀 타입을 선언할 때 박스를 활용함

<br>

**(1)** 리스트 생성자에 대한 더 자세한 정보
- 콘스 리스트(cons list; construction list) : 리스프(Lisp) 프로그래밍 언어 및 파생 언어에 도입된 데이터 구조
  - 리스프의 cons 함수는 보통 하나의 값과 값의 쌍으로 구성된 두 개의 인수를 이용해 새로운 쌍을 생성하며 이 쌍을 포함하는 쌍이 리스트를 구성하게 됨
  - 콘스 리스트의 각 아이템은 현재 아이템의 값과 그 다음 아이템의 값 등 두 개의 원소로 구성됨
    - 리스트의 마지막 아이템은 다음 아이템이 없으므로 Nil 이라는 값을 가짐
  - 이 리스트는 콘스 함수를 재귀적으로 호출해서 생성함
  - 재귀의 기본 상태(base case)를 뜻하는 정식 명칭은 Nil
  - 콘스 리스트는 함수형 프로그래밍 언어에서는 사용 빈도가 높지만, 러스트는 보편적으로 사용하지 않음
- 'x를 y에 콘스한다' : 원소 x를 y 리스트의 첫 부분에 추가해서 새로운 리스트를 생성한다는 의미

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```
- i32 값의 콘스 리스트 데이터 구조를 표현하는 열거자

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```
- List 열거자를 이용해 1, 2, 3 목록 저장
- `recursive type List has infinite size` 에러 발생
  - 어느 정도의 메모리 공간이 필요한지 판단할 수 없기 때문

<br>

**(2)** 비재귀 타입의 크기를 계산하는 방법

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
- 러스트는 Message 값을 저장하는 데 필요한 공간을 결정하기 위해 각 열것값을 모두 확인해서 어떤 열것값이 더 많은 공간을 차지하는지 확인함
- 단 하나의 열것값만 사용하므로 Message 값이 필요로 하는 공간은 가장 큰 열것값을 저장하는 데 필요한 공간임

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```
- 컴파일러는 Cons 열것값을 먼저 확인함
  - i32 타입과 List 타입의 값 저장
  - Cons는 i32 타입의 크기에 List 타입의 크기를 더한 공간이 필요함
  - List 타입에 필요한 공간을 확인하기 위해 컴파일러는 다시 Cons 열것값부터 살펴보기 시작함 -> 무한하게 반복됨

<br>

**(3)** `Box<T>` 를 이용해서 재귀 타입의 크기 결정하기

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2, 
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```
- 크기를 알고 있는 박스를 이용해 다시 선언한 List 열거자
  - `Box<T>` 는 포인터이므로 러스트는 박스가 필요한 공간이 얼마인지 알고 있음
  - `Box<T>` 는 Cons 열것값에 저장된 데이터가 아니라, 힙 메모리에 저장된 다음 List의 값을 가리킴
    - 이론적으로는 다른 리스트를 '저장하고 있는' 리스트를 가지게 됨
    - 한 리스트 안에 다른 리스트를 저장하는 것이 아닌 한 리스트 옆에 다른 아이템을 저장하는 셈
- 박스는 값의 간접적인 저장과 힙 메모리 할당만 지원하므로 어떠한 성능 오버헤드도 발생하지 않음

<br>

### **2️⃣ Deref 트레이트를 이용해 스마트 포인터를 참조처럼 취급하기**
- Deref 트레이트 구현 시 역참조 연산자 `*` 의 동작을 변경할 수 있음
  - 스마트 포인터를 참조처럼 취급할 수 있어 참조를 사용하는 코드를 그대로 스마트 포인터에도 적용 가능

#### **🤔 역참조 연산자를 이용해 포인터가 가리키는 값 읽어오기**
- 참조 : 일정의 포인터로 어딘가에 저장된 값을 가리키는 이정표

```rust
fn main() {
    let x = 5;
    let y = &x;
    
    assert_eq!(5 ,x);
    assert_eq!(5, *y);
    // assert_eq!(5, y) => 에러 발생
    // 숫자와 숫자에 대한 참조는 서로 다른 타입
}
```
- 역참조 연산자를 이용해 i32 값의 참조 따라가기
  - 변수 x는 i32 값인 5 저장
  - 변수 y는 x에 대한 참조 저장
    - y의 값 검증 시 *y 처럼 역참조 연산자를 덧붙여 변수가 가리키는 값의 참조를 따라가야 함
      - 즉, y를 역참조 시 y가 가리키는 값 5에 접근 가능

<br>

#### **🤔 `Box<T>` 를 참조처럼 사용하기**

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);
    
    assert_eq!(5 ,x);
    assert_eq!(5, *y);
}
```
- 변수 y에 x의 값을 가리키는 참조 대신 x의 값을 가리키는 박스의 인스턴스 대입

<br>

#### **🤔 직접 구현하는 스마트 포인터**

```rust
struct MyBox<T> (T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```
- T 타입의 원소 하나를 갖는 튜플 구조체 MyBox
- new 함수는 매개변수 하나를 가지며 그 값을 저장하는 MyBox 인스턴스 리턴

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
// Result
// type `MyBox<{integer}>` cannot be dereferenced
```
- `MyBox<T>` 타입은 역참조를 지원하는 Deref 트레이트를 구현하지 않았으므로 * 연산자의 역참조를 지원하지 않음

<br>

#### **🤔 Deref 트레이트를 구현해서 타입을 참조처럼 이용하기**

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T; // Deref 트레이트가 사용할 연관 타입 선언

    fn deref(&self) -> &T {
		// deref 메서드가 * 연산자를 통해 참조하고자 하는 값을 리턴
        &self.0
    }
}
```
- `MyBox<T>` 타입에 Deref 트레이트 구현
- Deref 트레이트를 구현하지 않으면 컴파일러는 & 참조만 역참조 가능

```rust
assert_eq!(5, *y);
*(y.deref()); // *y 코드 도달 시 내부적 실행 코드
```
- 러스트는 * 연산자를 deref 메서드 호출로 변환하고 역참조를 해석해서 개발자가 deref 메서드를 호출해야 하는지를 직접 결정하지 않도록 지원함
- deref 메서드가 값에 대한 참조를 리턴하는 이유
  - 소유권 시스템이 `*(y.deref())` 구문에서 괄호 바깥의 역참조를 요구하기 때문
  - deref 메서드가 값의 참조가 아니라 값을 직접 리턴하면 리턴된 값이 self 참조로 이동함
- 코드에서 * 연산자를 사용할 때마다 * 연산자는 deref 메서드 호출로 교체된 후 * 연산자를 한 번만 호출함
  - 무한한 재귀호출이 아니므로 값을 얻게 됨