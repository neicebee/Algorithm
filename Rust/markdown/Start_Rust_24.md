# 🦀 Rust Day 24

## **🏳️ Smart Pointers**
- 포인터(pointer) : 메모리에 주소를 가지고 있는 변수를 일컫는 보편적인 개념
- 러스트의 참조
  - & 기호 이용해 지정
  - 변수가 가리키는 값을 대여함
  - 별도의 오버헤드 없음
- 스마트 포인터(smart pointer) : 포인터처럼 동작할 뿐만 아니라 추가적인 메타데이터와 기능을 포함하는 데이터 구조
  - 참조는 데이터를 대여할 수만 있지만, 스마트 포인터는 대부분 포인터가 가리키는 데이터를 소유함
  - `String` 과 `Vec<T>` 타입 모두 메모리를 소유하며 데이터를 갱신할 수 있으므로 스마트 포인터
    - 메타데이터(저장 용량 등)와 추가 기능이나 보장(String은 모든 데이터가 항상 유효한 UTF-8 문자임을 보장)을 제공
  - 스마트 포인터는 주로 구조체를 이용해 구현함
    - 일반 구조체와 달리 Deref와 Drop 트레이트를 구현함
    - Deref : 스마트 포인터 구조체가 참조처럼 동작해서 참조나 스마트 포인터를 같은 방법으로 다룰 수 있도록 지원
    - Drop : 스마트 포인터의 인스턴스가 범위를 벗어날 때 임의의 코드를 실행하도록 지원

### **1️⃣ `Box<T>` 를 이용해 힙 메모리의 데이터 참조하기**
- 박스(`Box<T>`) : 가장 직관적인 스마트 포인터 
  - 데이터를 힙 메모리에 저장함
  - 스택에는 힙 데이터를 가리키는 포인터만 저장함
  - 박스를 사용하는 예
    - 컴파일타임에 크기를 알 수 없는 타입을 정확한 크기가 필요한 상황에 사용하려고 할 때
    - 데이터의 크기가 커서 데이터를 복제하지 않고 소유권을 이전하고 싶을 때
    - 특정 타입이 아니라 특정 트레이트를 구현하는 타입의 값을 소유하고자 할 때

#### **🤔 `Box<T>` 를 이용해 힙 메모리에 데이터 저장하기**

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```
- 박스를 이용해 i32값을 힙 메모리에 저장
  - 소유된 값과 마찬가지로 박스가 범위를 벗어나면 메모리가 해제됨(박스와 박스가 가리키는 데이터의 메모리가 모두 해제)

<br>

#### **🤔 박스를 이용해 재귀 타입 활용하기**
- 재귀 타입(recursive type) : 같은 타입의 다른 값을 자신의 일부에 포함하는 값
  - 값을 중첩하는 것은 이론적으로 무한할 수 있어서 러스트는 재귀 타입의 값을 저장하는 데 필요한 공간을 판단할 수 없음
  - 박스의 크기는 정해져 있으므로 재귀 타입을 선언할 때 박스를 활용함

<br>

**(1)** 리스트 생성자에 대한 더 자세한 정보
- 콘스 리스트(cons list; construction list) : 리스프(Lisp) 프로그래밍 언어 및 파생 언어에 도입된 데이터 구조
  - 리스프의 cons 함수는 보통 하나의 값과 값의 쌍으로 구성된 두 개의 인수를 이용해 새로운 쌍을 생성하며 이 쌍을 포함하는 쌍이 리스트를 구성하게 됨
  - 콘스 리스트의 각 아이템은 현재 아이템의 값과 그 다음 아이템의 값 등 두 개의 원소로 구성됨
    - 리스트의 마지막 아이템은 다음 아이템이 없으므로 Nil 이라는 값을 가짐
  - 이 리스트는 콘스 함수를 재귀적으로 호출해서 생성함
  - 재귀의 기본 상태(base case)를 뜻하는 정식 명칭은 Nil
  - 콘스 리스트는 함수형 프로그래밍 언어에서는 사용 빈도가 높지만, 러스트는 보편적으로 사용하지 않음
- 'x를 y에 콘스한다' : 원소 x를 y 리스트의 첫 부분에 추가해서 새로운 리스트를 생성한다는 의미

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```
- i32 값의 콘스 리스트 데이터 구조를 표현하는 열거자

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```
- List 열거자를 이용해 1, 2, 3 목록 저장
- `recursive type List has infinite size` 에러 발생
  - 어느 정도의 메모리 공간이 필요한지 판단할 수 없기 때문

<br>

**(2)** 비재귀 타입의 크기를 계산하는 방법

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
- 러스트는 Message 값을 저장하는 데 필요한 공간을 결정하기 위해 각 열것값을 모두 확인해서 어떤 열것값이 더 많은 공간을 차지하는지 확인함
- 단 하나의 열것값만 사용하므로 Message 값이 필요로 하는 공간은 가장 큰 열것값을 저장하는 데 필요한 공간임

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```
- 컴파일러는 Cons 열것값을 먼저 확인함
  - i32 타입과 List 타입의 값 저장
  - Cons는 i32 타입의 크기에 List 타입의 크기를 더한 공간이 필요함
  - List 타입에 필요한 공간을 확인하기 위해 컴파일러는 다시 Cons 열것값부터 살펴보기 시작함 -> 무한하게 반복됨

<br>

**(3)** `Box<T>` 를 이용해서 재귀 타입의 크기 결정하기

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2, 
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```
- 크기를 알고 있는 박스를 이용해 다시 선언한 List 열거자
  - `Box<T>` 는 포인터이므로 러스트는 박스가 필요한 공간이 얼마인지 알고 있음
  - `Box<T>` 는 Cons 열것값에 저장된 데이터가 아니라, 힙 메모리에 저장된 다음 List의 값을 가리킴
    - 이론적으로는 다른 리스트를 '저장하고 있는' 리스트를 가지게 됨
    - 한 리스트 안에 다른 리스트를 저장하는 것이 아닌 한 리스트 옆에 다른 아이템을 저장하는 셈
- 박스는 값의 간접적인 저장과 힙 메모리 할당만 지원하므로 어떠한 성능 오버헤드도 발생하지 않음