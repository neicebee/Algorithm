# 🦀 Rust Day 14

## **🏳️ Common Collections**
- 내장된 배열과 튜플과는 달리 컬렉션이 가리키는 데이터는 힙 메모리에 저장됨
  - 데이터의 크기를 컴파일 시점에 알 필요가 없으며, 프로그램의 실행 중에 얼마든지 그 크기를 증가시키거나 감소시킬 수 있음
- `벡터(vector)` : 연속된 일련의 값을 저장함
- `문자열(string)` : `문자(character)` 의 컬렉션
- `해시 맵(hash map)` : 특정 키에 값을 연결할 때 사용. 해시 맵은 더 범용으로 사용되는 `맵(map)` 을 구현한 구현체임

<br>

### **1️⃣ 벡터에 일련의 값 저장하기**
- `Vec<T>` 타입
  - 벡터를 이용하면 하나 이상의 값을 하나의 데이터 구조에 담을 수 있으며 모든 값은 메모리상에 연속으로 저장됨
  - 어떤 타입이든 저장 가능
  - 특정한 타입 저장 시 해당 타입에 대한 애노테이션을 명시해주어야 함
  - 같은 타입의 값만을 저장할 수 있음

#### **🤔 새로운 벡터 생성하기**

```rust
fn main() {
    let v: Vec<i32> = Vec::new();
}
```
- `Vec::new` 함수로 새로운 빈 벡터 생성
- 타입에 대한 애노테이션 명시
- 벡터는 `제네릭(generic)` 을 이용해 구현됨
- 러스트는 벡터에 일단 값을 추가하면 그 타입을 유추할 수 있음
  - 빈 벡터를 생성하지 않는 이상 타입 애노테이션을 사용할 일이 별로 없음

```rust
fn main() {
    let v = vec![1, 2, 3];
}
```
- 지정한 값을 저장하는 새로운 백터를 생성하는 `vec!` 매크로
- 초깃값 지정 시 `i32` 타입의 값을 지정했으므로 타입 애노테이션을 추가할 필요가 없음

#### **🤔 벡터 수정**

```rust
fn main() {
    let mut v = Vec::new();
    v.push(4);
    v.push(5);
    v.push(6);
    v.push(7);
}
```
- `push` 메서드를 이용해 벡터에 값 추가

#### **🤔 벡터 해제**
- 다른 구조체와 마찬가지로 벡터 역시 범위를 벗어날 때 `drop` 메서드가 호출됨
- 벡터가 메모리에서 해제되면 벡터에 저장된 모든 값도 함께 해제됨
  - 모든 정수값도 해제됨
- 벡터에 참조형 값을 저장하는 경우에는 일이 복잡해질 수 있음

#### **🤔 벡터로부터 값 읽기**

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("세 번째 원소 : {third}");
}
// Result
// 세 번째 원소 : 3
```
- `인덱스 문법(indexing syntax)` 이용
- `&` 와 `[]` 를 이용해 저장된 값에 대한 참조를 리턴


```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    match v.get(2) {
        Some(third) => println!("세 번째 원소 : {third}"),
        None => println!("세 번째 원소가 없음."),
    }
}
// Result
// 세 번째 원소 : 3
```
- `get` 메서드 이용
- `Option<&T>` 타입의 값 리턴

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let no_value = &v[100];
    let no_value = v.get(100);
}
```
- 벡터의 존재하지 않는 인덱스의 값에 접근할 때 `[]` 방식은 `패닉(panic)` 발생
  - 지정된 참조가 존재하지 않는 값을 가리키기 때문
- `get` 메서드로 존재하지 않는 인덱스의 값에 접근하면 `None` 값이 리턴됨

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);
}
```
- **_필자의 `rustc` 버전은 `1.62.0` 인데 에러가 발생하지 않음_**
  - 일단 개념은 정리해두려고 함
- 프로그램이 유효한 참조값을 얻게 되면 벡터에 저장된 값에 대한 참조가 계속해서 유효할 수 있도록 대여값 검사가 실행되어 소유권과 대여 규칙을 적용함
- 같은 범위 내에서 가변 참조와 불변 참조를 동시에 가질 수 없음
- 현재 벡터의 크기가 충분히 크지 않다면 벡터의 마지막에 새로운 값을 추가하기 위해 새로운 메모리를 할당하고 이미 저장된 값들을 새로운 메모리 공간으로 옮겨야 할 수도 있음

#### **🤔 벡터에 저장된 값을 순회하기**

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];

    for i in &v {
        println!("{i}");
    }
}
// Result
// 1
// 2
// 3
// 4
// 5
// 6
```
- `for` 문을 이용해 벡터에 저장된 값에 대한 불변 참조를 얻어와 출력함

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];

    for i in &mut v {
        *i += 50;
        println!("{i}");
    }
}
// Result
// 51
// 52
// 53
// 54
// 55
// 56
```
- 가변 벡터에 저장된 값에 대한 가변 참조를 얻어와 값을 변경함
- 가변 참조가 가리키는 값을 변경하려면 `+=` 연산자 사용 전에 `역참조 연산자(*)` 를 이용해 변수 `i` 에 저장된 값을 가져와야 함

#### **🤔 열거자를 이용해 여러 타입 저장하기**
- 열거자의 열것값은 같은 열거자 타입으로 평가되므로 벡터에 다른 타입의 값을 저장하려면 열거자를 정의해 사용하면 됨

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

fn main() {
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(3.14),
        SpreadsheetCell::Text(String::from("가나다라")),
    ];
}
```
- 열거자를 이용해 하나의 벡터에 다른 타입의 값 저장
- 벡터에 어떤 값을 저장할 수 있는지 명시할 수 있음
  - 러스트는 컴파일 시점에 벡터에 어떤 타입의 값이 저장될지 알아야 하므로 당연히 각각의 값을 저장하기 위해 어느 정도의 힙 메모리가 필요한지도 정확히 판단함
- 프로그램이 벡터에 저장해야 할 타입들을 프로그램을 작성하는 시점에 완벽히 알 수 없다면 열거자를 이용하는 방법은 별다른 도움이 되지 않음

### **2️⃣ `String` 타입에 `UTF-8` 형식의 텍스트 저장하기**
- 러스트의 문자열은 일반적으로 개발자들이 알고 있는 것보다 더 복잡한 데이터 구조이며, `UTF-8` 형식으로 저장됨
- 러스트의 문자열은 `바이트(bytes)` 의 컬렉션으로 구현되어 있을 뿐만 아니라, 이 바이트를 문자열로 처리할 때 유용한 여러 가지 메서드를 제공함

#### **🤔 문자열이란 무엇일까?**
- 러스트는 언어의 명세 안에서 오직 한 가지의 문자열 타입, 즉 문자열 슬라이스인 `str` 타입만을 지원함
  - 주로 값을 대여한 `&str` 의 형태로 보게 될 것임
  - 어딘가에 `UTF-8` 형식으로 인코딩되어 저장된 문자열에 대한 참조
  - 문자열 리터럴은 프로그램을 컴파일한 바이너리 결과 파일에 포함되므로 문자열 슬라이스임
- `String` 타입은 언어의 명세에 정의된 것이 아니라 러스트의 표준 라이브러리가 제공하는 타입
  - 길이 조정이나 내용 변경, 소유 등이 가능하며 `UTF-8` 형식으로 인코딩된 문자열 타입
- 러스트의 표준 라이브러리는 `OsString`, `OsStr`, `CString`, `CStr` 과 같은 다른 종류의 문자열 타입도 제공
  - 이 문자열 타입들은 다른 인코딩 형식의 텍스트를 저장하거나 메모리상에 다른 형태로 표현되기도 함

#### **🤔 새 문자열 생성하기**