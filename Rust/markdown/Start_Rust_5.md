# 🦀 Rust Day 5

## **🏳️ Common Programming Concepts**
- `keyword` : 개발자가 사용할 수 없는 예약 키워드 존재 -> 다른 언어와 같음

### **1️⃣ 변수와 가변성**
- 러스트는 변수의 불변성(immutability)을 기본으로 하며, 경우에 따라 회피할 수 있음
  - 기본 변수 선언문 `let x = 5;` 을 사용했을 때는 불변성 적용
  - 변수 앞에 `mut` keyword 추가 시 가변 변수 선언 가능
    - `let mut x = 5;`
  - **_대용량 데이터 구조 사용 시 데이터의 인스턴스를 가변형으로 선언하는 것이 유리_**
  - **_작은 용량의 데이터 구조 사용 시 새로운 인스턴스 생성 후 함수형 프로그래밍 기법에 가깝게 코딩하는 것이 유리_**

#### **🤔 변수 vs 상수**
- 상수에는 `mut` keyword 사용 불가능
  - 상수는 항상 _불변_
- `let` keyword 대신 `const` keyword 사용하여 선언
  - 할당할 값의 타입을 무조건 지정하여야 함 => _annotation_
- 전역 범위를 비롯해 원하는 어떤 범위 내에서도 선언 가능
- 반드시 상수 표현식을 사용하여 값을 할당
  - _함수 호출 결과값이나 기타 런타임 연산으로 얻은 값 사용 불가능_
- 러스트에서는 상수 이름에 _대문자_ 만 사용하며 _snack case_ 를 기용한다는 규칙 사용
  - 밑줄은 숫자 리터럴의 가독성을 높이기 위해 자릿수 구분 시 사용 가능
- 상수는 프로그램 실행 중 선언된 범위 내에서 항상 유효한 값
- 프로그램 전체에서 사용하는 하드코드된 값에 상수로 이름을 지정하는 것은 매우 괜찮은 선택
    ```rust
    const MAX_NUM: u32 = 100_000;

    fn main() {
        println!("Max_num: {}", MAX_NUM);
    }

    // Result
    // Max_num: 100000
    ```

#### **🤔 변수 가리기 (shadowing)**
- 이미 선언한 변수의 이름과 같은 이름의 변수 선언 가능
  - 이전에 선언한 변수는 새로 선언한 변수 때문에 가려짐
  - **_변수 이름을 참조하면 두 번째 변수의 값이 사용됨_**
- `let` keyword를 이용해 재선언 시 `shadowing`
- **`shadowing`** vs **`mut` keyword**
  - `shadowing` 은 `let` keyword 를 사용하기 때문에 변경된 값도 불변
  - `let` keyword 를 사용할 때 새로운 변수를 선언하는 것이므로 이름은 같지만, 타입은 다른 변수 사용 가능
    - ex) 사용자에게 특정 텍스트 사이에 삽입하고 싶은 갯수만큼 공백을 입력하게 한 후 숫자로 변환 사용 가능
        ```rust
        fn main() {
            let spaces = "      ";
            let spaces = spaces.len();

            println!("공백: {}", spaces);
        }
        // Result
        // 공백: 6
        ```
        ```rust
        fn main() {
            let mut spaces = "      ";
            spaces = spaces.len();

            println!("공백: {}", spaces);
        }
        // Result
        // error[E0308]: mismatched types
        ```

### **2️⃣ 데이터 타입**
- 러스트의 데이터 타입의 두 가지 부분집합
  - 스칼라(Scalar)
  - 컴파운드(Compound)
- 러스트는 정적 타입 언어
  - 즉, 컴파일 시점에 모든 변수의 타입이 결정되어야 함
  - _컴파일러는 타입 추론을 통해 변수에 할당된 값이나 변수의 사용을 보고 실제 타입 예측_
- 여러 타입을 사용할 수 있을때는 `타입 애노테이션 (annotation)` 을 이용해 타입을 명시해주어야 함

#### **🤔 Scalar Type**
- 정수(integer)와 부동 소수점 숫자(floating point numbers), 불린(booleans), 문자(characters) 등 네 가지 종류의 `Scalar Type` 정의
  - **☝️ 정수 타입**
    - 소수점이 없는 숫자
    - [정수 타입]  
        | 크기 | 부호 O | 부호 X |
        | --- | --- | --- |
        | 8bit | i8 | u8 |
        | 16bit | i16 | u16 |
        | 32bit | i32 | u32 |
        | 64bit | i64 | u64 |
        | arch | isize | usize |
    - 부호가 있는 타입은 할당값이 음수나 양수일 수 있으므로 이를 구분하기 위해 부호가 필요함
    - 부호가 있는 숫자는 2의 보수로 표현
    - [2의 보수 정리글](https://it-neicebee.tistory.com/133)
    - 부호가 있는 타입들은 $-(2^{n-1})$ 과 $2^{n-1}-1$ 사잇값들을 보관할 수 있음
      - _n은 각 타입의 크기를 나타내는 비트의 개수_
    - `isize` 나 `usize`는 현재 프로그램이 실행중인 컴퓨터의 종류에 따라 그 크기가 달라짐
    - [정수 리터럴]
        | 숫자 리터럴 | Ex |
        | --- | --- |
        | Decimal | 98_222 |
        | Hex | 0xff |
        | Octal | 0o77 |
        | Binary | 0b1111_0000 |
        | Byte(u8 전용) | b'A' |
    - 바이트 제외 모든 숫자 리터럴에는 57u8과 같이 타입 접미사(suffix)를 붙일 수 있음
    - 밑줄로 자릿수 표현 가능
    - 정수의 기본 타입: `i32`
      - 일반적으로 가장 빠르며 64bit 플랫폼에서도 빠름
      - isize나 usize 타입은 컬렉션 타입의 인덱스 참조 시 주로 사용
    - **__정수 오버플로우__**
      - u8 타입의 변수에 255가 넘는 값을 대입하려하면 정수 오버플로우가 발생 (integer overflow)
      - 디버그 모드로 컴파일하면 러스트는 정수 오버플로우에 대한 검사를 추가하여 런타임에 프로그램에서 **_패닉_**이 발생하지 않도록 함
        - **__Panicking__** : 에러가 발생해서 프로그램이 중단되는 현상
      - `--release` 플래그를 이용하여 릴리즈 모드로 컴파일 할 경우 패닉을 유발하는 정수 오버플로우에 대한 검사를 추가하지 않음
      - 대신 오버플로우가 발생하면 두 개의 래핑(Wrapping) 을 추가
        - **__Wrapping__** : 타입의 최댓값보다 큰 값은 타입이 가질 수 있는 가장 작은 값으로 둘러쌓임
      - 정수 오버플로우의 래핑 동작에 의존하는 것은 에러로 판단. 만일, 값을 명시적으로 래핑하고자 한다면 표준 lib의 Wrapping 타입 사용
  - **☝️ 부동 소수점 타입**
    - f32와 f64
      - 각각 32bit와 64bit 크기
    - 요즘 사용하는 대부분 CPU에서는 f64가 f32만큼 빠르고 정확도가 더 높으므로 러스트의 기본 타입으로 규정함
    - f32 타입은 단정도(single-precision) 부동 소수점 표현
    - f64 타입은 배정도(double-precision) 부동 소수점 표현
  - **☝️ 사칙 연산**
    ```rust
    let sum 6 + 12;
    let dif = 95.5 - 63.2;
    let pro = 4 * 20;
    let quo = 56.7 / 32.2;
    let reminder = 43 % 5;
    ```
    - 사칙 연산자 이용하여 하나의 값 편가 후 변수에 할당
  - **☝️ 불린 타입**
    - `true`, `false`
    - 크기는 1byte
  - **☝️ 문자 타입**
    - char 타입은 언어가 제공하는 가장 기본적인 알파벳 타입
      - char 리터럴은 작은 따옴표 표현
    - 4bytes 크기의 유니코드 스칼라값
    - 유니코드 스칼라값의 범위는 `U+0000 ~ U+D7FF`, `U+E000 ~ U+10FFFF` 까지의 값 포함

#### **🤔 Compound Type**
- 하나의 타입으로 여러 개의 값을 그룹화한 타입
- 기본적으로 튜플(tuples)과 배열(arrays) 등 두 가지 컴파운드 타입 지원
  - **☝️ 튜플 타입**
    - 서로 다른 타입의 여러 값을 하나의 컴파운드 타입으로 그룹화하기에 적합한 타입
    - 고정 길이를 가지며, 한 번 정의하면 그 크기를 키우거나 줄일 수 없음
    - `type annotation` 적용 가능
    - 튜플에서 개별 값을 읽으려면 패턴 매칭을 이용해 튜플 값을 해체(destruct) 할 수 있음
        ```rust
        fn main() {
            let tup = (500, 6.4, 1);
            let (x, y, z) = tup;

            println!("{}, {}, {}", x, y, z);
        }
        // Result
        // 500, 6.4, 1
        ```
        - `let` 구문에 패턴을 지정해 tup 변수에 할당된 값들을 개변 변수에 각각 대입
        ```rust
        fn main() {
            let tup = (500, 6.4, 1);

            println!("{}, {}, {}", tup.0, tup.1, tup.2);
        }
        ```
        - 인덱스를 지정하여 destruct 하기
  - **☝️ 배열 타입**
    - 튜플과 달리 배열의 각 요소는 반드시 같은 타입
    - 러스트의 배열은 일부 다른 언어의 배열과 달리 _고정 길이_
    - 배열은 다루고자 하는 데이터를 힙(heap) 이 아닌 **_스택 (stack)_** 메모리에 할당하거나 **_항상 고정된 개수의 요소_** 를 다룰 때 유용
    - Ex1) `let a: [i32; 5] = [1, 2, 3, 4, 5];`
      - `i32 타입의 원소가 5개` 지정
    - Ex2) `let a = [3; 5];`
      - 각 원소에 같은 값을 가진 배열 선언
    - `Vector` 만큼 유연하지 않음
      - `Vector` : 표준 lib이 지원. 배열과 유사하지만 크기를 자유롭게 조정 가능. **_배열과 벡터 중 어느 것을 사용해야 할지 확실치 않을때는 벡터를 선택하는 편이 좋음_**
  - **☝️ 배열 요소 접근**
    - 배열은 스택에 할당된 한 덩어리의 메모리
    - 접근 시 인덱스 활용
  - **☝️ 유효하지 않은 배열 요소에 접근**
    - 컴파일은 가능하지만 에러 발생 => 런타임 에러
    - 지정된 인덱스가 배열 전체 길이보다 작은 값인지 검사 후 인덱스가 배열 길이보다 크다면 `Panic` 발생
    - **_러스트의 안정성 원리 개입의 최초 예시_**
      - _엉뚱한 메모리에 대한 접근을 허용하는 대신 프로그램을 즉각 중단하는 보호 장치 제공_