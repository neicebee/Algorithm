# 🦀 Rust Day 18

## **🏳️ Error Handling**
- 러스트는 에러의 발생 가능성을 인지하고 개발자가 코드를 컴파일하기 전에 에러를 처리하도록 유도함
- 대부분 언어는 에러를 구분하지 않고 `예외(exception)` 같은 메커니즘을 이용해 똑같이 처리함
- 러스트에 예외라는 개념은 존재하지 않으며, 에러를 두 가지로 구분하고 있음
- `회복 가능한 에러(recoverable error)`
  - 존재하지 않는 파일 등 회복 가능한 에러는 사용자에게 문제를 보고하고 작업을 다시 시도하도록 요청할 수 있음
  - `Result<T, E>` 타입으로 표현
- `회복이 불가능한 에러(unrecoverable error)`
  - 회복 불가능한 에러는 배열의 범위를 벗어나는 메모리에 대한 접근처럼 항상 버그의 가능성을 내포하고 있음
  - 해당 에러가 발생한 프로그램은 `panic!` 매크로를 바인딩하며 실행을 종료함

<br>

### **1️⃣ `panic!` 매크로를 이용한 회복 불가능한 에러 처리**
- 패닉은 대부분 어떤 종류의 버그가 발견되었는데 개발자가 이 에러를 처리할 방법이 마땅치 않을 때 활용
- `panic!` 매크로를 실행하면 프로그램은 실패 메시지를 출력하고, 스택을 모두 정리한 다음 종료함
- **패닉이 발생했을 때 스택을 풀어주거나(unwind) 취소하기**
  - 기본적으로 패닉이 발생하면 프로그램은 스택을 풀기 시작
    - 역순으로 순회하며 각 함수에 전달되었던 데이터 정리
    - 이를 위해 실행되는 작업의 양은 상당함
  - 스택을 즉시 취소해서 스택을 정리하지 않고 애플리케이션을 종료하는 방법
    - 프로그램이 사용하던 메모리는 OS가 정리해야 함
    - 프로그램의 바이너리 파일의 크기를 최대한 작게 해야 한다면 `Cargo.toml` 파일의 `[profile]` 섹션에 `panic = 'abort'` 를 추가하면 스택을 풀어주지 않고 취소할 수 있음
    - 릴리즈 모드에서 패닉을 취소할 시
        ```bash
        [profile.release]
        panic = 'abort'
        ```

```rust
fn main() {
    panic!("Error!");
}
```
- `panic!` 매크로를 호출하면 마지막 두 줄에 에러 메시지가 표시됨
- 첫 번째 줄에 패닉 메시지와 패닉이 발생한 소스 코드의 위치가 출력됨
- `src/main.rs:4:5` => `src/main.rs` 파일의 네 번째 줄 네 번째 문자

#### **🤔 `panic!` 역추적 사용하기**

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```
- 벡터의 크기를 벗어나는 인덱스를 이용해 값을 읽을 때, `panic!` 매크로 호출
- C 같은 다른 언어는 이런 경우 원치 않던 값이라도 개발자가 지정한 위치의 값을 리턴함
  - `버퍼 오버리드(buffer overread)`
    - 인덱스로 지정한 위치의 메모리가 벡터가 관리하는 메모리가 아니더라도 벡터에 저장된 값에 해당하는 위치의 메모리에 저장된 값을 리턴함
    - 공격자가 해당 방법으로 인덱스를 조작해서 읽어서는 안 되는 값을 읽게 되는 보안상의 취약점이 되기 쉬움
- `panic!` 매크로가 바인딩된 실행 결과에 있는 노트에는 `RUST_BACKTRACE` 환경 변수를 이용해 정확히 어떻게 에러가 발생했는지를 역추적할 수 있다는 것을 알려줌
  - 역추적은 그 지점까지 호출된 모든 함수의 목록
  - 제일 위의 함수부터 우리가 작성한 파일까지 함수의 호출 과정을 추적하는 것
- 역추적 정보를 얻으려면 `디버그 심볼(debug symbols)` 이 활성화되어 있어야 함
  - `cargo build` 나 `cargo run` 명령을 `--release` 플래그 없이 실행하면 기본적으로 활성화됨

<br>

### **2️⃣ `Result` 타입으로 에러 처리하기**
- 대부분 에러는 프로그램을 완전히 종료해야 할 정도로 치명적이지는 않음

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
- `Result` 열거자 정의 코드
- `T` 와 `E` 는 제네릭 타입 매개변수
- `T` 는 작업이 성공한 경우 `Ok` 열것값 안에 포함될 값의 타입
- `E` 는 작업이 실패한 경우 `Err` 열것값 안에 포함될 값의 타입

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("File Open Error: {:?}", error);
        }
    };

}
```
- match 표현식으로 Result 타입의 리턴값을 제어하는 코드
- `Option` 열거자와 마찬가지로 `Result` 열거자도 프렐류드에 의해 자동으로 추가됨

#### **🤔 `match` 표현식으로 여러 종류의 에러 처리하기**
